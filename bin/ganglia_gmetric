#!/usr/bin/env perl
use strict;
my $VERSION = 0.01;

#
# This program is copyright 2010-Forever Dathan Pattishall dathan@rockyou.com
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.
#



# ###########################################################################
# GmetricDelegate package
#  assume this is a abstract class and getData getCounterMetricHash/getAbsoluteMetricHash need to be defined in the
#  "subclass"
#
package GmetricDelegate;
#
# this is built via a make file
#
my $GMETRIC = "/usr/bin/gmetric";

sub new {
	my $class = shift;
	my $self  = {};
	bless($self, $class);
	return $self;
}

sub getGmetricCMD(){
	my $self = shift;
	return '/usr/bin/gmetric';
}

sub getSaveFileDir(){
	my $self = shift;
	return "/var/tmp";
}

#
# get the last data points for a possible delta
#

sub getLastState { 
	my $self = shift;

	my $tmp_dir_base	= $self->getSaveFileDir();
	my $tmp_stats_file	= $self->getFileName(); 
	if (! -d $tmp_dir_base ){
		system("/bin/mkdir -p $tmp_dir_base");
	}

	if (! -e $tmp_stats_file ){
		return; # 1st run no file?
	}

	open(FH, "<$tmp_stats_file") or die($!);
	while(<FH>){
		my($k,$v) = split(/:/, $_);
		$self->{prev_data}{$k} = $v;
	}
	
	return $self->{prev_data};
}

#
# save it for processing later
#

sub saveState {
	my $self		= shift;
	my $key_value	= shift;

	my $file		= $self->getFileName();

	open(DUMP, ">$file") or die ($!);
	
	for my $k (keys %{$key_value}){
		chomp($k);
		chomp($key_value->{$k});
		print DUMP "$k:$key_value->{$k}\n";
	}
	close(DUMP);
}

#
# define this in the subclass
#
sub getPackagePrefix {
	my $self = shift;
	return '';
}

#
# define this in the subclass
#

sub getCounterMetricHash{
	my $self = shift;
	my $counter = {};

	return $counter; 
}

#
# define this in the subclass
#

sub getAbsoluteMetricHash{
	my $self = shift;
	my $absolute = {};
	return $absolute;
}

#
# define this in the subclass
#

sub getData{
	my $self = shift;
	my $data = {};
	return $data;
}

#
# send the stuff to ganglia
#

sub sendGmetricData($$$){
	my $self			= shift;
	my $dataNow			= shift;
	my $dataLastRun		= shift;

	my $counter_metrics		= $self->getCounterMetricHash();
	my $absolute_metrics	= $self->getAbsoluteMetricHash();
	my $gmetric_command		= $self->getGmetricCMD();
	my $units = '';
	my $ganglia_prefix      = $self->getPackagePrefix();

	#Get the time stamp when the stats file was last modified
	my $old_time = (stat $self->getFileName())[9];
	my $timedelta = 1;
	if ($old_time){
		$timedelta = time() - $old_time;
	}
	foreach my $metric (keys %{$dataNow}){
		my $cmd = '';	
		next if ($dataNow->{$metric} !~ /\d+/); #not a number then skip
		if ($units = $counter_metrics->{$metric}){
			my $rate = ($dataNow->{$metric} - $dataLastRun->{$metric})/$timedelta;
			$cmd  = $gmetric_command . " -u '$units/sec' -tfloat -n $ganglia_prefix" . $metric . " -v " . $rate;
			print $cmd,"\n";

		} else {
			if (!($units = $absolute_metrics->{$metric})){
				$units = 'operations';
			}
			my $absolute = $dataNow->{$metric};
			$cmd = $gmetric_command . " -u '$units/sec' -tfloat -n $ganglia_prefix" . $metric . " -v " . $absolute;
			print $cmd,"\n";
		}
		system($cmd);
	}
}

#
# do it.
#
sub run() {
	my $self = shift;

	my $dataLastRun = $self->getLastState();
	my $dataNow     = $self->getData();
	$self->sendGmetricData($dataNow, $dataLastRun);
	$self->saveState($dataNow);
	return 1;
}

1;

#
# This program is copyright 2010-Forever Dathan Pattishall dathan@rockyou.com
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.
#


# ###########################################################################
# GmetricCassandra package
#  this is a subclass of GmetricDelegate. It defines  getData getCounterMetricHash/getAbsoluteMetricHash
#

package GmetricCassandra;
use strict;



use base qw(GmetricDelegate);
our $VERSION = 0.01;

sub new {
	my $class = shift;
	my $self  = {};
	bless($self, $class);
	return $self;
}


#
# choose this method instead of parsing JMX since its more portable and less dependancies. additionally this is suppose
# to run on the cassandra boxes
#

sub getNodeToolCMD(){

	my $self = shift;

	return "/opt/cassandra/bin/nodetool --host localhost --port " . $self->getCassandraPort();

}
sub getCassandraPort(){

	my $self = shift;
	
	return '8181';
}

sub getFileName {
	my $self = shift;
	$self->{save_file_name} = $self->getSaveFileDir() . "/cassandra.gmetric.data";
	return $self->{save_file_name};
}

sub setData {
	my $self = shift;
	my $data = shift;
	
	$self->{gmetric_data} = $data;
}

sub getData {
	my $self = shift;
	
	$self->{current_data} = {};
	my $tpstats = $self->gettpstatsData();
	my $cfstats = $self->getcfstatsData();
	foreach my $k(keys %{$tpstats}){
		$self->{current_data}{lc($k)} = $tpstats->{$k};
	}
	foreach my $k(keys %{$cfstats}){
		if ($self->{current_data}{lc($k)}){
			print "What key already exists\n";
		}
		$self->{current_data}{lc($k)} = $cfstats->{$k};
	}
	
	
			

	return $self->{current_data};
	
}

sub gettpstatsData{
	my $self = shift;
	my $cmd  = $self->getNodeToolCMD() . " tpstats";

	open(CMD, $cmd . "|") or die("$cmd:$!\n");
	my $hashref = {};
	while(<CMD>){
		next if ($_ =~ /^Pool Name/);
		my ($key, $active, $pending, $completed) = split(/\s+/, $_);
		$hashref->{'tpa_'.$key} = $active;
		$hashref->{'tpp_'.$key} = $pending;
		$hashref->{'tpc_'.$key} = $completed;

	}
	return $hashref;
	close CMD;
}

sub getcfstatsData{
	my $self = shift;
	my $cmd  = $self->getNodeToolCMD() . " cfstats";

	open(CMD, $cmd . "|") or die("$cmd:$!\n");
	my $hashref = {};
	my $found_user_keyspace = 0;
	my $prefix = '';
	while(<CMD>){

		next if ($_ !~ /^--.+/ && $found_user_keyspace == 0);
		$found_user_keyspace = 1;
		
		next if ($_ =~ /^--.+/);
		my $line = $_;
		chomp($line);
		$line =~ s/^\t+//g;
		next if (!$line);

		if ($line =~ /^Keyspace: (\S+)/){
			$prefix = "ks_$1";
			next;
		}

		if ($line =~ /^Column Family: (\S+)/){
			$prefix = "cf_$1";
			next;
		}

		my ($k, $v) = split(":", $line);
		$k =~ s/\s+/_/g;
		$v =~ s/\s+//g;
		$v =~ s/ms\.//g;
		$v =~ s/NaN/0/g;
		$k =~ s/\((\S+)\)/$1/g;
		$hashref->{$prefix . '_' . $k} = $v;

	}
	return $hashref;
	close CMD;
}

sub getinfoData {
	my $self = shift;
}

sub getPackagePrefix{
	return 'cass_';
}

sub getCounterMetricHash{
	my $self = shift;

	my $counter = {
#
# customize cf and ks stats
#
		'cf_treeclick_write_count' => 'writes',
		'cf_standard2_memtable_switch_count' => 'switches',
		'cf_complex_write_count' => 'writes', 
		'cf_treeclick_memtable_columns_count' => 'columns',
		'cf_treeclick_memtable_switch_count' => 'switches',
		'cf_complex_read_count' => 'reads',
		'cf_standardbytime_read_count' => 'reads',
		'cf_standard2_read_count' => 'reads',
		'cf_standardbytime_write_count' => 'writes',
		'cf_standard2_memtable_columns_count' => 'columns',
		'cf_standardbytime_memtable_switch_count' => 'switches',
		'cf_complex_memtable_columns_count' => 'columns',
		'cf_complex_memtable_switch_count' => 'switches',
		'ks_timeframeclicks_read_count' => 'reads',
		'ks_timeframeclicks_write_count' => 'writes',
		'cf_standard2_write_count' => 'writes',
		'cf_treeclick_read_count' => 'reads',
		'cf_standardbytime_memtable_columns_count' => 'columns',
		'cf_standard2_memtable_data_size' => 'growth',
#
# tpstats
#
		'tpc_response-stage' => 'responses',
		'tpc_row-read-stage' => 'row_reads',
		'tpc_lb-operations'  => 'operations',
		'tpc_message-deserializer-pool' => 'deserializations',
		'tpc_gmfd' => '?',
		'tpc_lb-target' => 'operations',
		'tpc_consistency-manager' => 'operations',
		'tpc_row-mutation-stage' => 'mutations',
		'tpc_message-streaming-pool' => 'streams',
		'tpc_load-balancer-stage'    => 'operations',
		'tpc_flush-sorter-pool'      => 'operations',
		'tpc_memtable-post-flusher' => 'flushes',
		'tpc_flush-writer-pool' => 'writes',
		'tpc_ae-service-stage' => 'operations',
		'tpc_hinted-handoff-pool' => 'operations',
		'tpc_messaging-service-pool' => 'operations',
		'tpc_commitlog' => 'commits',
		'tpc_compaction-pool' => 'compactions',
	};
	return $counter;
}

#
# i might remove this as its seen its not needed.
#
sub getAbsoluteMetricHash{
	my $self = shift;
	my $absolute = {
		'tpa_response-stage'                    => 'responses',
		'tpa_row-read-stage'                    => 'row_reads',
		'tpa_lb-operations'                     => 'operations',
		'tpa_message-deserializer-pool'			=> 'deserializations',
		'tpa_gmfd'								=> '?',
		'tpa_lb-target'                         => 'operations',
		'tpa_consistency-manager'               => 'operations',
		'tpa_row-mutation-stage'                => 'mutations',
		'tpa_message-streaming-pool'			=> 'streams',
		'tpa_load-balancer-stage'               => 'operations',
		'tpa_flush-sorter-pool'                 => 'operations',
		'tpa_memtable-post-flusher'             => 'flushes',
		'tpa_flush-writer-pool'                 => 'writes',
		'tpa_ae-service-stage'                  => 'operations',
		'tpa_hinted-handoff-pool'               => 'operations',
		'tpa_messaging-service-pool'			=> 'operations',
		'tpa_commitlog'							=> 'commits',
		'tpa_compaction-pool'                   => 'compactions',
		'tpp_response-stage'                    => 'responses',
		'tpp_row-read-stage'                    => 'row_reads',
		'tpp_lb-operations'						=> 'operations',
		'tpp_message-deserializer-pool'			=> 'deserializations',
		'tpp_gmfd'                              => '?',
		'tpp_lb-target'                         => 'operations',
		'tpp_consistency-manager'               => 'operations',
		'tpp_row-mutation-stage'                => 'mutations',
		'tpp_message-streaming-pool'			=> 'streams',
		'tpp_load-balancer-stage'               => 'operations',
		'tpp_flush-sorter-pool'                 => 'operations',
		'tpp_memtable-post-flusher'             => 'flushes',
		'tpp_flush-writer-pool'                 => 'writes',
		'tpp_ae-service-stage'                  => 'operations',
		'tpp_hinted-handoff-pool'               => 'operations',
		'tpp_messaging-service-pool'			=> 'operations',
		'tpp_commitlog'                         => 'commits',
		'tpp_compaction-pool'                   => 'compactions',

	};
	return $absolute;
}

1;

#!/usr/bin/env perl


# This is ganglia_gmetric_tmpl, a program send stat information to ganglia
#
# This program is copyright 2007-2010 Dathan Vance Pattishall
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.


my %config = (
		module => 'GmetricCassandra',
);

use Getopt::Long;
Getopt::Long::Configure('no_ignore_case', 'bundling');
GetOptions(
		"module|s=s"   => \$config{module},
);

#
# if eval error
#
if ($@){
	die("The module $config{module} cannot be loaded was it installed?:$@");
}

#
# initialize the object and run the gmetric
#
my $gmc = $config{module}->new();
$gmc->run();
